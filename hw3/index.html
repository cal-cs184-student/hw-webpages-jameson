<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      h1 {
        text-align: center;
      }

      .container {
        margin: 0 auto;
        padding: 60px 20%;
      }

      figure {
        text-align: center;
      }

      img {
        display: inline-block;
      }

      body {
        font-family: "Inter", sans-serif;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
      <div style="text-align: center">Jameson Crate and Akshaan Ahuja</div>

      <br />

      Link to webpage:
      <a
        href="https://cal-cs184-student.github.io/hw-webpages-jameson/hw3/index.html"
        >https://cal-cs184-student.github.io/hw-webpages-jameson/hw3/index.html</a
      >
      <br />
      Link to GitHub repository:
      <a href="https://github.com/cal-cs184-student/sp25-hw3-make-my-ray"
        >https://github.com/cal-cs184-student/sp25-hw3-make-my-ray</a
      >

      <figure>
        <img
          src="images/example_image.png"
          alt="Cornell Boxes with Bunnies"
          style="width: 70%"
        />
      </figure>

      <h2>Overview</h2>
      In this assignment, we implemented a ray tracer in C++ and used it to
      render a few scenes. We first implemented a simple ray generator and
      intersection test for triangles. We then used this to render the Cornell
      Box with a few different objects. Next we implemented a BVH to speed up
      the intersection test. We then implemented direct illumination and global
      illumination with Russian Roulette. Finally, we implemented adaptive
      sampling to improve the quality of our images.

      <h2>Part 1: Ray Generation and Scene Intersection</h2>
      <p>
        A ray is generated by interpreting the (x,y) coordinates of each sample
        in the image plane as points on a virtual “sensor” in the camera space,
        using the camera&apos;s field of view (fov variables in the code) to map
        those normalized coordinates into a 3D direction. That direction is then
        normalized and transformed into the world coordinate system (originating
        at the camera&apos;s position) with the near and far clipping distances
        applied into the min_t and max_t fields of the ray. For triangle
        intersections, we used the Moller–Trumbore algorithm: two edges of the
        triangle are calculated and then a bunch of cross and dot products to
        find the position "t" along the ray and the barycentric coordinates of
        the point on the triangle&apos;s surface using barycentric
        interpolation. If t is within the ray&apos;s valid range (set by min_t
        and max_t earlier up) and all barycentric coordinates lie between 0 and
        1, the intersection is valid; at which point, the intersection record is
        updated accordingly (updating isect and the new max_t).
      </p>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-1/CBbunny.png" width="400px" />
              <figcaption>Cornell Box with Bunny</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-1/CBcoil.png" width="400px" />
              <figcaption>Cornell Box with Coil</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-1/CBgems.png" width="400px" />
              <figcaption>Cornell Box with Gems</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-1/CBspheres.png" width="400px" />
              <figcaption>Cornell Box with Spheres</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h2>Part 2: Bounding Volume Hierarchy</h2>
      <p>
        In order to speed up ray tracing, we use a Bounding Volume Hierarchy
        (BVH). Typically when ray tracing, we have to check every single
        primative in the scene to see if it intersects with the ray. A BVH is a
        tree structure where each node contains a bounding box, leaf nodes each
        contain a subset of the scenes primatives, and internal nodes contain
        pointers to nodes with smaller bounding boxes of subdivisions of
        primatives. In order to check for intersection we can check if the ray
        intersects the root bounding box which is a very efficient operation. If
        it does not intersect the bounding box then we know it doesn't intersect
        any of the children of the current node so we don't need to continue to
        compute intersections. If it does intersect the bounding box we can
        recursively call the intersection test on all nodes that the ray
        intersects until we have processed each of the primitives or found
        bounding boxes that the ray doesn't intersect with.
      </p>
      <p>
        In order to construct the bvh we first draw a bounding box around all of
        the primatives. We then compute the mean of the center of each of our
        primatives and split our primatives into two groups based if the center
        of the primative falls on the left or the right (for x and y axes) of
        the mean or above or below the mean (for z axis). Each split divides the
        space into two bounding boxes. We compute the surface area of each
        bounding box and choose which of these axes to split on based on the
        minimum of the maximum of each of the axes' bounding boxes. This ensures
        that our splits are as even as possible. We recursively apply this split
        to each of the bounding boxes until we have a BVH with leaf nodes
        containing less than m primatives.
      </p>
      <p>
        Below are several images generated with our BVH implementation. To
        compare the performance of our BVH we rendered the Bunny and Coil scenes
        with and without the BVH. Without the BVH these renderings took 85
        seconds and 23 seconds respectively. With the BVH these renderings took
        0.07 seconds and 0.08 seconds. That is over 1,200x faster in the case of
        the bunny and 250x faster in the case of the coil. The Dragon and Lucy
        scenes took far too long to render without the BVH, but with the BVH
        they are rendered in less than a second.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-2/CBbunny.png" width="400px" />
              <figcaption>Cornell Box with Bunny</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-2/CBcoil.png" width="400px" />
              <figcaption>Cornell Box with Coil</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-2/CBdragon.png" width="400px" />
              <figcaption>Cornell Box with Dragon</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-2/CBlucy.png" width="400px" />
              <figcaption>Cornell Box with Lucy</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h2>Part 3: Direct Illumination</h2>
      <p>
        With our Bounding Volume Hierarchy we can now turn toward the problem of
        simulating light transport in the scene. Our camera will only register
        light which reaches it. We can break up the light reaching the camera
        into the light coming directly from light sources and the light that
        bounces off of materials from light sources. In this section we do not
        consider additional bounces of light from surface to surface, as we will
        do that in part 4. In order to determine how much light reaches a
        specific pixel of the camera's sensor we can either just return the
        amount of light emitted in the case of zero-bounce light and, for
        once-bounce light, we can use the reflection equation and sampling /
        montecarlo integration to estimate the amount of light coming out of
        this surface along the ray pointing to the camera.
      </p>
      <p>
        We implemenet two different ways of sampling the irradiance falling on
        some point in the scene. The first is uniform hemisphere sampling where
        we sample uniformly from a hemisphere surrounding the point. This
        sampling method is sufficient for computing and unbiased estimator of
        the integral of all light falling on this point; however, it is often
        noisy. In order to get a less noisy result we can implement our second
        sampling method: importance sampling. In importance sampling we sample a
        ray from a camera to get an intersection with a point and then for each
        light in the scene sample several rays which point from the point to
        some point on the lamp. If the ray doesn't intersect anything before the
        light then we know the irradiance that falls on the surface from this
        light in the scene. This is sufficient for our purposes when we
        considering only one-bounce light because all radiance in the scene
        comes from light sources.
      </p>
      <p>
        Below are some results from uniform hemisphere sampling and importance
        sampling. We can see that the hemisphere sampled points are much noiser
        for scenes with less samples. These differences begin to converge with
        more samples as both are unbiased estimators of the actual integral, but
        our importance sampled scene appears to converge to the expected output
        faster due to its nature. Since the sampled rays which dont interect
        with lights do not add any one-bounce light to the scene, we can get
        closer to the actual result faster by not sampling these rays and
        instead only sampling rays which will intersect with lights and add
        one-bounce light to the scene.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_H_16_8.png" width="400px" />
              <figcaption>
                Hemisphere Sampled Bunny: 16 Rays Per Pixel
              </figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_H_64_32.png" width="400px" />
              <figcaption>
                Hemisphere Sampled Bunny: 64 Rays Per Pixel
              </figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_16_8.png" width="400px" />
              <figcaption>
                Importance Sampled Bunny: 16 Rays Per Pixel
              </figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_64_32.png" width="400px" />
              <figcaption>
                Importance Sampled Bunny: 64 Rays Per Pixel
              </figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-3/CBspheres_H_16_8.png" width="400px" />
              <figcaption>
                Hemisphere Sampled Spheres: 16 Rays Per Pixel
              </figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-3/CBspheres_H_64_32.png" width="400px" />
              <figcaption>
                Hemisphere Sampled Spheres: 64 Rays Per Pixel
              </figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-3/CBspheres_16_8.png" width="400px" />
              <figcaption>
                Importance Sampled Spheres: 16 Rays Per Pixel
              </figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-3/CBspheres_64_32.png" width="400px" />
              <figcaption>
                Importance Sampled Spheres: 64 Rays Per Pixel
              </figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_1_1.png" width="400px" />
              <figcaption>Bunny: 1 Sample Per Pixel, 1 Light Ray</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_1_4.png" width="400px" />
              <figcaption>Bunny: 1 Sample Per Pixel, 4 Light Rays</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_1_16.png" width="400px" />
              <figcaption>Bunny: 1 Sample Per Pixel, 16 Light Rays</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-3/CBbunny_1_64.png" width="400px" />
              <figcaption>Bunny: 1 Sample Per Pixel, 64 Light Rays</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h2>Part 4: Global Illumination</h2>
      <p>
        In our code, we first got a local coordinate frame whose z-axis aligns
        with the surface normal at the intersection point (0, 0, 1). We
        transform the outgoing direction (looking back toward the camera) into
        this local space, where the material’s BSDF can be sampled more easily.
        If we are accumulating multiple bounces, we add the “one_bounce” direct
        lighting contribution from the local hit before moving on. We may then
        either apply Russian Roulette checking to decide whether to end the
        light path early; if we continue, we sample a new incoming direction
        from the BSDF in local coordinates and transform it back to world space.
        Next, we form a new ray slightly offset from the surface to avoid self
        collisions and trace it through the scene. If that new ray hits another
        surface and we still have bounces left, we recursively call the same
        function on that next intersection. The returned radiance from the
        subsequent bounces is multiplied by the BSDF value, the cosine of the
        angle between our sampled direction and the local normal, and an
        additional probability factor to ensure the method stays "unbiased"
        under Russian Roulette termination checking. Finally, we divide by the
        probability density from the BSDF sampling and add the result to our
        indirect lighting estimate for this point to get our L_out return.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/gems.png" width="400px" />
              <figcaption>Gems 1024 Samples Per Pixel</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/wall-e.png" width="400px" />
              <figcaption>Wall-E 1024 Samples Per Pixel</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/building.png" width="400px" />
              <figcaption>Building 1024 Samples Per Pixel</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/banana.png" width="400px" />
              <figcaption>Banana 1024 Samples Per Pixel</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/bunny_direct.png" width="400px" />
              <figcaption>Bunny Only Direct Light</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_indirect.png" width="400px" />
              <figcaption>Bunny Only Indirect Light</figcaption>
            </td>
          </tr>
        </table>
      </div>
      <p>
        Below we consider the difference between multiple bounces of light and
        how they accumulate. The top images show the light only added at that
        bounce and the bottom row shows the total accumulated light in the image
        at that step. We can see that before the second step the ceiling is
        unlit. With the second bounce we add that lighting to the scene. The
        third bounce adds even more subtlety to the scene by making everything
        look slightly brighter and more realistic.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce0.png" width="300px" />
              <figcaption>Bunny: 0 Bounces</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce1.png" width="300px" />
              <figcaption>Bunny: 1 Bounce</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce2.png" width="300px" />
              <figcaption>Bunny: 2 Bounces</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce3.png" width="300px" />
              <figcaption>Bunny: 3 Bounces</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce4.png" width="300px" />
              <figcaption>Bunny: 4 Bounces</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce5.png" width="300px" />
              <figcaption>Bunny: 5 Bounces</figcaption>
            </td>
          </tr>
        </table>
      </div>
      <br />
      <br />
      <br />
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce0_accum.png" width="300px" />
              <figcaption>Bunny: 0 Bounces (Accumulated)</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce1_accum.png" width="300px" />
              <figcaption>Bunny: 1 Bounce (Accumulated)</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce2_accum.png" width="300px" />
              <figcaption>Bunny: 2 Bounces (Accumulated)</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce3_accum.png" width="300px" />
              <figcaption>Bunny: 3 Bounces (Accumulated)</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce4_accum.png" width="300px" />
              <figcaption>Bunny: 4 Bounces (Accumulated)</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/bunny_bounce5_accum.png" width="300px" />
              <figcaption>Bunny: 5 Bounces (Accumulated)</figcaption>
            </td>
          </tr>
        </table>
      </div>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/CBbunny_rr_1024_16_0.png" width="400px" />
              <figcaption>Bunny Russian Roulette, 0 Max Depth</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/CBbunny_rr_1024_16_1.png" width="400px" />
              <figcaption>Bunny Russian Roulette, 1 Max Depth</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/CBbunny_rr_1024_16_2.png" width="400px" />
              <figcaption>Bunny Russian Roulette, 2 Max Depth</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/CBbunny_rr_1024_16_3.png" width="400px" />
              <figcaption>Bunny Russian Roulette, 3 Max Depth</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/CBbunny_rr_1024_16_4.png" width="400px" />
              <figcaption>Bunny Russian Roulette, 4 Max Depth</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/CBbunny_rr_1024_16_100.png" width="400px" />
              <figcaption>Bunny Russian Roulette, 100 Max Depth</figcaption>
            </td>
          </tr>
      </div>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/dragon_1_4.png" width="400px" />
              <figcaption>Dragon: 1 Sample Per Pixel</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/dragon_2_4.png" width="400px" />
              <figcaption>Dragon: 2 Samples Per Pixel</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/dragon_4_4.png" width="400px" />
              <figcaption>Dragon: 4 Samples Per Pixel</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/dragon_8_4.png" width="400px" />
              <figcaption>Dragon: 8 Samples Per Pixel</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="images/part-4/dragon_16_4.png" width="400px" />
              <figcaption>Dragon: 16 Samples Per Pixel</figcaption>
            </td>
            <td style="text-align: center">
              <img src="images/part-4/dragon_64_4.png" width="400px" />
              <figcaption>Dragon: 64 Samples Per Pixel</figcaption>
            </td>
          </tr>
        </table>
        <br />
        <img src="images/part-4/dragon_1024_4.png" width="400px" />
        <figcaption>Dragon: 1024 Samples Per Pixel</figcaption>
      </div>

      <h2>Part 5: Adaptive Sampling</h2>
      <p>
        Adaptive sampling lets the renderer decide, on a per‐pixel basis of
        sorts, when it has accumulated enough samples to produce a stable result
        without wasting extra computation. In other words, it measures the
        current estimate’s variability and stops sampling early if the pixel’s
        color is already sufficiently converged to its rendered color. For each
        pixel, our code begins taking samples, which are just rays, and
        accumulating the resulting color. It also keeps track of the luminance
        of each sample in two running sums s1 and s2. Every samplesPerBatch
        samples, we calculate the current sample mean and variance from the
        running sums we calculated earlier. A 95% confidence‐interval I is then
        computed to determine whether or not we deem the pixel has converged or
        not. We keep going if the pixel hasn't converged yet.
      </p>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <figure>
              <td style="text-align: center">
                <img src="images/part-5/bunny.png" width="400px" />
                <figcaption>
                  Bunny Scene Rendered With Adaptive Sampling
                </figcaption>
              </td>
            </figure>
            <td style="text-align: center">
              <figure>
                <img src="images/part-5/bunny_rate.png" width="400px" />
                <figcaption>Bunny Scene Sampling Rate</figcaption>
              </figure>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <figure>
                <img src="images/part-5/spherical.png" width="400px" />
                <figcaption>
                  Spheres Scene Rendered With Adaptive Sampling
                </figcaption>
              </figure>
            </td>
            <td style="text-align: center">
              <figure>
                <img src="images/part-5/spherical_rate.png" width="400px" />
                <figcaption>Spheres Scene Sampling Rate</figcaption>
              </figure>
            </td>
          </tr>
        </table>
      </div>
    </div>
  </body>
</html>
